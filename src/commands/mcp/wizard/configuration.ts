import { RegistryServer } from '@src/domains/registry/types.js';
import printer from '@src/utils/ui/printer.js';

import boxen from 'boxen';
import chalk from 'chalk';
import prompts from 'prompts';

import { showStepIndicator } from './display.js';
import { deriveLocalName, extractArgMetadata, extractEnvVarMetadata } from './metadata.js';

/**
 * Configuration collection result
 */
export interface ConfigurationResult {
  version?: string;
  localName?: string;
  tags?: string[];
  env?: Record<string, string>;
  args?: string[];
  cancelled: boolean;
  goBack?: boolean;
  forceOverride?: boolean;
}

/**
 * Collect configuration (tags, env, args)
 */
export async function collectConfiguration(
  server: RegistryServer,
  existingNames: string[] = [],
): Promise<ConfigurationResult> {
  console.clear();
  showStepIndicator(3, 5, 'Configure');

  printer.raw(
    boxen(chalk.magenta.bold(`‚öôÔ∏è  Configure: ${server.name}`), {
      padding: 1,
      borderStyle: 'round',
      borderColor: 'magenta',
    }),
  );

  // Derive auto-generated name
  const autoGeneratedName = deriveLocalName(server.name);

  // Local name with conflict detection
  let localName = autoGeneratedName;
  let nameConflict = existingNames.includes(localName);
  let forceOverride = false;

  while (true) {
    const localNameInput = await prompts({
      type: 'text',
      name: 'localName',
      message: nameConflict
        ? chalk.yellow(`‚ö†Ô∏è  Server '${localName}' already exists. Enter a different name:`)
        : `Local server name:`,
      initial: localName,
    });

    if (localNameInput.localName === undefined) {
      return { cancelled: true };
    }

    localName = String(localNameInput.localName).trim();

    // Check for conflict
    if (existingNames.includes(localName)) {
      nameConflict = true;

      // Ask user what to do
      const conflictAction = await prompts({
        type: 'select',
        name: 'action',
        message: `Server '${localName}' already exists. What would you like to do?`,
        choices: [
          { title: 'Rename (enter a different name)', value: 'rename' },
          { title: 'Override (replace existing server)', value: 'override' },
          { title: 'Cancel installation', value: 'cancel' },
        ],
        initial: 0,
      });

      if (conflictAction.action === 'cancel' || conflictAction.action === undefined) {
        return { cancelled: true };
      }

      if (conflictAction.action === 'override') {
        // User wants to override - set flag and break the loop
        forceOverride = true;
        break;
      }

      // If 'rename', loop continues with nameConflict still true
      continue;
    }

    // No conflict, proceed
    break;
  }

  // Tags - default to server name
  const defaultTags = autoGeneratedName;
  const tagsInput = await prompts({
    type: 'text',
    name: 'tags',
    message: 'Tags (comma-separated):',
    initial: defaultTags,
  });

  if (tagsInput.tags === undefined) {
    return { cancelled: true };
  }

  // Configure environment variables interactively
  const env = await configureEnvVars(server);
  if (env === null) {
    return { cancelled: true };
  }

  // Configure arguments interactively
  const args = await configureArgs(server);
  if (args === null) {
    return { cancelled: true };
  }

  const tagsValue = String(tagsInput.tags || '').trim();
  const tags = tagsValue
    ? tagsValue
        .split(',')
        .map((t: string) => t.trim())
        .filter((t: string) => t.length > 0)
    : undefined;

  return {
    localName: localName || undefined,
    tags,
    env: env || undefined,
    args: args || undefined,
    cancelled: false,
    forceOverride,
  };
}

/**
 * Configure environment variables interactively
 */
export async function configureEnvVars(server: RegistryServer): Promise<Record<string, string> | null> {
  const envVarMetadata = extractEnvVarMetadata(server);

  if (envVarMetadata.length === 0) {
    // No env vars defined, ask if user wants to add any manually
    const addManual = await prompts({
      type: 'confirm',
      name: 'add',
      message: 'No environment variables defined. Add any manually?',
      initial: false,
    });

    if (addManual.add === undefined) {
      return null;
    }

    if (!addManual.add) {
      return {};
    }

    // Allow manual JSON input
    const manualInput = await prompts({
      type: 'text',
      name: 'env',
      message: 'Environment variables (JSON):',
      initial: '{}',
      validate: (value: string) => {
        try {
          JSON.parse(value);
          return true;
        } catch {
          return 'Invalid JSON format';
        }
      },
    });

    if (manualInput.env === undefined) {
      return null;
    }

    return JSON.parse(String(manualInput.env)) as Record<string, string>;
  }

  // Show summary of available env vars
  printer.raw(chalk.cyan.bold('\nüìã Available Environment Variables:'));
  printer.raw(chalk.gray(`   Found ${envVarMetadata.length} environment variables\n`));

  // Ask if user wants to configure any
  const wantsToConfigure = await prompts({
    type: 'confirm',
    name: 'value',
    message: `Configure environment variables?`,
    initial: envVarMetadata.some((v) => v.isRequired),
  });

  if (wantsToConfigure.value === undefined) {
    return null;
  }

  if (!wantsToConfigure.value) {
    // Use defaults only for required vars
    const env: Record<string, string> = {};
    envVarMetadata.forEach((envVar) => {
      if (envVar.default && envVar.isRequired) {
        env[envVar.key] = envVar.default;
      }
    });
    return env;
  }

  // Let user select which env vars to configure
  const choices = envVarMetadata.map((envVar) => {
    const required = envVar.isRequired ? chalk.red('*required') : '';
    const secret = envVar.isSecret ? chalk.yellow('üîí ') : '';
    const title = `${secret}${envVar.key} ${required}`;
    const description = envVar.description || '';
    return {
      title,
      description,
      value: envVar.key,
      selected: envVar.isRequired || false, // Pre-select required vars
    };
  });

  const selection = await prompts({
    type: 'multiselect',
    name: 'selected',
    message: 'Select environment variables to configure (use space to select, enter to confirm):',
    choices,
    hint: '- Space to select. Enter to submit',
    instructions: false,
  });

  if (selection.selected === undefined) {
    return null;
  }

  const selectedKeys = selection.selected as string[];
  if (selectedKeys.length === 0) {
    return {};
  }

  // Prompt for each selected env var
  printer.raw(chalk.cyan.bold('\nüìù Configure Selected Variables:\n'));
  const env: Record<string, string> = {};

  for (const key of selectedKeys) {
    const envVar = envVarMetadata.find((v) => v.key === key);
    if (!envVar) continue;

    const result = await prompts({
      type: envVar.isSecret ? 'password' : 'text',
      name: 'value',
      message: `${envVar.key}${envVar.isRequired ? chalk.red(' *') : ''}:${envVar.description ? `\n   ${chalk.gray(envVar.description)}` : ''}`,
      initial: envVar.default || '',
    });

    if (result.value === undefined) {
      // User can skip by pressing Ctrl+C on individual fields
      continue;
    }

    const value = String(result.value).trim();
    if (value) {
      env[envVar.key] = value;
    } else if (envVar.isRequired) {
      printer.raw(chalk.yellow(`‚ö†Ô∏è  ${envVar.key} is required, using default or empty value`));
      env[envVar.key] = envVar.default || '';
    }
  }

  return env;
}

/**
 * Configure runtime arguments interactively
 */
export async function configureArgs(server: RegistryServer): Promise<string[] | null> {
  const argMetadata = extractArgMetadata(server);

  if (argMetadata.length === 0) {
    // No args defined, ask if user wants to add any manually
    const addManual = await prompts({
      type: 'confirm',
      name: 'add',
      message: 'No runtime arguments defined. Add any manually?',
      initial: false,
    });

    if (addManual.add === undefined) {
      return null;
    }

    if (!addManual.add) {
      return [];
    }

    // Allow manual input
    const manualInput = await prompts({
      type: 'text',
      name: 'args',
      message: 'Arguments (comma-separated):',
      initial: '',
    });

    if (manualInput.args === undefined) {
      return null;
    }

    const argsValue = String(manualInput.args).trim();
    return argsValue
      ? argsValue
          .split(',')
          .map((a: string) => a.trim())
          .filter((a: string) => a.length > 0)
      : [];
  }

  // Show summary of available args
  printer.raw(chalk.cyan.bold('\n‚öôÔ∏è  Available Runtime Arguments:'));
  printer.raw(chalk.gray(`   Found ${argMetadata.length} runtime arguments\n`));

  // Ask if user wants to configure any
  const wantsToConfigure = await prompts({
    type: 'confirm',
    name: 'value',
    message: `Configure runtime arguments?`,
    initial: argMetadata.some((a) => a.isRequired),
  });

  if (wantsToConfigure.value === undefined) {
    return null;
  }

  if (!wantsToConfigure.value) {
    // Use defaults only for required args
    return argMetadata.filter((a) => a.isRequired && a.default).map((a) => `${a.name}=${a.default}`);
  }

  // Let user select which args to configure
  const choices = argMetadata.map((arg) => {
    const required = arg.isRequired ? chalk.red('*required') : '';
    const name = arg.name || 'argument';
    const title = `${name} ${required}`;
    const description = arg.description || '';
    return {
      title,
      description,
      value: arg.name || '',
      selected: arg.isRequired || false, // Pre-select required args
    };
  });

  const selection = await prompts({
    type: 'multiselect',
    name: 'selected',
    message: 'Select runtime arguments to configure (use space to select, enter to confirm):',
    choices,
    hint: '- Space to select. Enter to submit',
    instructions: false,
  });

  if (selection.selected === undefined) {
    return null;
  }

  const selectedNames = selection.selected as string[];
  if (selectedNames.length === 0) {
    return [];
  }

  // Prompt for each selected arg
  printer.raw(chalk.cyan.bold('\nüìù Configure Selected Arguments:\n'));
  const args: string[] = [];

  for (const name of selectedNames) {
    const arg = argMetadata.find((a) => a.name === name);
    if (!arg) continue;

    let result;
    if (arg.choices && arg.choices.length > 0) {
      result = await prompts({
        type: 'select',
        name: 'value',
        message: `${arg.name || 'Argument'}${arg.isRequired ? chalk.red(' *') : ''}:${arg.description ? `\n   ${chalk.gray(arg.description)}` : ''}`,
        choices: arg.choices.map((c) => ({ title: c, value: c })),
        initial: arg.default ? arg.choices.indexOf(arg.default) : 0,
      });
    } else {
      result = await prompts({
        type: 'text',
        name: 'value',
        message: `${arg.name || 'Argument'}${arg.isRequired ? chalk.red(' *') : ''}:${arg.description ? `\n   ${chalk.gray(arg.description)}` : ''}`,
        initial: arg.default || '',
      });
    }

    if (result.value === undefined) {
      // User can skip by pressing Ctrl+C on individual fields
      continue;
    }

    const value = String(result.value).trim();
    if (value) {
      // Format as name=value for CLI args
      args.push(`${arg.name}=${value}`);
    } else if (arg.isRequired && arg.default) {
      printer.raw(chalk.yellow(`‚ö†Ô∏è  ${arg.name} is required, using default value`));
      args.push(`${arg.name}=${arg.default}`);
    }
  }

  return args;
}

/**
 * Ask if user wants to install another server
 */
export async function askInstallAnother(): Promise<boolean> {
  const result = await prompts(
    {
      type: 'confirm',
      name: 'another',
      message: 'Install another server?',
      initial: false,
    },
    {
      onCancel: () => {
        return false;
      },
    },
  );

  return Boolean(result.another);
}
